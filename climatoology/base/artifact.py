import json
import logging
import uuid
from enum import Enum
from numbers import Number
from pathlib import Path
from typing import Optional, Union, List, Dict, Tuple
from uuid import UUID

import rasterio
from PIL.Image import Image
from affine import Affine
from geopandas import GeoSeries, GeoDataFrame
from numpy.typing import ArrayLike
from pandas import DataFrame
from pydantic import BaseModel, Field, model_validator, conlist, field_serializer
from pydantic_extra_types.color import Color
from rasterio import CRS
from rasterio.profiles import DefaultGTiffProfile

from climatoology.base.computation import ComputationResources

log = logging.getLogger(__name__)


class ArtifactModality(Enum):
    """Available artifact types."""
    MARKDOWN = 'MARKDOWN'
    TABLE = 'TABLE'
    IMAGE = 'IMAGE'
    CHART = 'CHART'
    MAP_LAYER_GEOJSON = 'MAP_LAYER_GEOJSON'
    MAP_LAYER_GEOTIFF = 'MAP_LAYER_GEOTIFF'


class Artifact(BaseModel):
    """A result generated by a Plugin."""

    name: str = Field(description='A short name for the artifact that could be used as an alias.',
                      min_length=1,
                      examples=['Nice Graphic'])
    modality: ArtifactModality = Field(description='The type of artefact created.',
                                       examples=[ArtifactModality.IMAGE])
    file_path: Path = Field(description='The full path to the file that stores the artefact.',
                            examples=['/tmp/7dbcabe2-0961-44ad-b8a2-03a61f45d059_image.png'])
    summary: str = Field(description='A short description of the artifact that could be used in a caption.',
                         min_length=1,
                         examples=['This image shows A.'])
    description: Optional[str] = Field(description='A long description of the generated output that may help users '
                                                   'better understand the artifact.',
                                       min_length=1,
                                       examples=['This image shows A and was taken from B by C because of D.'],
                                       default=None)
    correlation_uuid: Optional[UUID] = Field(description='Do not set! The correlation UUID for this call. Will be '
                                                         'automatically set by the plugin.',
                                             default=None)
    store_id: Optional[str] = Field(description='Do not set! This is the pointer to the file in the artifactory store. '
                                                'Will be automatically set.',
                                    examples=['7dbcabe2-0961-44ad-b8a2-03a61f45d059_image.png'],
                                    default=None)


class ChartType(Enum):
    SCATTER = 'SCATTER'
    LINE = 'LINE'
    BAR = 'BAR'
    PIE = 'PIE'


class Chart2dData(BaseModel):
    x: Union[conlist(float, min_length=1), conlist(str, min_length=1)] = Field(title='X values',
                                                                               description='Data values on the X axis. '
                                                                                           'Must be the same length as '
                                                                                           'y values. Only one of both '
                                                                                           'can be a nominal variable '
                                                                                           '(string). For Pie-Charts, '
                                                                                           'all values must be '
                                                                                           'positive numbers. They '
                                                                                           'will be interpreted as '
                                                                                           'share, i.e. divided by '
                                                                                           'the sum.',
                                                                               examples=[['first', 'second', 'third']])
    y: Union[conlist(float, min_length=1), conlist(str, min_length=1)] = Field(title='Y values',
                                                                               description='Data values on the Y axis. '
                                                                                           'Must be the same length as '
                                                                                           'x values. Only one of both '
                                                                                           'can be a nominal variable '
                                                                                           '(string).',
                                                                               examples=[[3, 2, 1]])
    chart_type: ChartType = Field(title='Chart Type',
                                  description='The type of chart to be created.',
                                  examples=[ChartType.SCATTER])
    color: Union[Color, List[Color]] = Field(title='Chart Color',
                                             description='The color for the chart elements. If a list is given, it '
                                                         'must be the same length as the data input. If only a single '
                                                         'color is given, all elements will have the same color. Line-'
                                                         'Charts accept only a single color (one line=one color).',
                                             examples=[['#590d08', '#590d08', '#590d08']],
                                             default='#590d08',
                                             validate_default=True)

    @model_validator(mode='after')
    def check_length(self) -> 'Chart2dData':
        assert len(self.x) == len(self.y), 'X and Y data must be the same length.'

        if self.chart_type == ChartType.LINE:
            assert isinstance(self.color, Color), 'Line charts can only have a single color for the line.'
        else:
            assert isinstance(self.color, Color) or (len(self.color) == len(self.x)), ('Data and color lists must be '
                                                                                       'the same length.')

        return self

    @model_validator(mode='after')
    def check_type(self) -> 'Chart2dData':
        assert (isinstance(self.x[0], float) or isinstance(self.y[0],
                                                           float)), 'Only one dimension can be nominal (a str).'
        return self

    @model_validator(mode='after')
    def check_data(self) -> 'Chart2dData':
        if self.chart_type == ChartType.PIE:
            assert isinstance(self.y[0], float), 'Pie-chart Y-Axis must be numeric.'
            assert all(val >= 0 for val in self.y), 'Pie-chart Y-Data must be all positive.'
            y_sum = sum(self.y)
            self.y = [val / y_sum for val in self.y]
        return self

    @field_serializer('color')
    def serialize_color_list(self, co: Union[Color, List[Color]], _info):
        if isinstance(co, Color):
            return co.as_hex()
        else:
            return [c.as_hex() for c in co]


def create_markdown_artifact(text: str,
                             resources: ComputationResources,
                             name: str,
                             tl_dr: str,
                             filename: str = uuid.uuid4()) -> Artifact:
    """Create an artifact from text supporting Markdown formatting.

    You may use raw text or add any formatting to style your text using e.g. headings, emphasis or links.

    :param text: Text that can contain Markdown formatting.
    :param name: A potential heading for the text.
    :param tl_dr: A summary of the text.
    :param resources: The computation resources for this plugin.
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.md'
    log.debug(f'Writing markdown file {file_path}')

    with open(file_path, 'x') as out_file:
        out_file.write(text)

    result = Artifact(name=name,
                      modality=ArtifactModality.MARKDOWN,
                      file_path=file_path,
                      summary=tl_dr)
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_table_artifact(data: DataFrame,
                          title: str,
                          caption: str,
                          resources: ComputationResources,
                          description: str = None,
                          filename: str = uuid.uuid4()) -> Artifact:
    """Create an artifact from a data frame.

    This will create a CSV file. Any index will be written as a normal column.

    :param data: Table to save as csv.
    :param title: Title or name of the table.
    :param caption: Caption of the table that describes the content.
    :param description: A longer description of the table content.
    :param resources: The computation resources for this plugin.
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.csv'
    log.debug(f'Writing table {file_path}')

    data = data.reset_index()
    data.to_csv(file_path,
                header=True,
                index=False,
                index_label=False,
                mode='x')

    result = Artifact(name=title,
                      modality=ArtifactModality.TABLE,
                      file_path=file_path,
                      summary=caption,
                      description=description)
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_image_artifact(image: Image,
                          title: str,
                          caption: str,
                          resources: ComputationResources,
                          description: str = None,
                          filename: str = uuid.uuid4()) -> Artifact:
    """Create an artifact from a pillow image.

    This will create a PNG file.

    :param image: Image to save as PNG.
    :param title: Title or name of the image.
    :param caption: Caption of the image that describes the content.
    :param description: A longer description of the image content.
    :param resources: The computation resources for this plugin.
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.png'
    log.debug(f'Writing image {file_path}')

    image.save(file_path,
               format='PNG',
               optimize=True)

    result = Artifact(name=title,
                      modality=ArtifactModality.IMAGE,
                      file_path=file_path,
                      summary=caption,
                      description=description)
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_chart_artifact(data: Chart2dData,
                          title: str,
                          caption: str,
                          resources: ComputationResources,
                          description: str = None,
                          filename: str = uuid.uuid4()) -> Artifact:
    """Create a chart artifact.

    This will create a JSON file holding all information required to plot a simple 2d chart.

    :param data: Chart data
    :param title: Title for the resulting plot.
    :param caption: Caption for the resulting plot that describes the content.
    :param description: A longer description of the chart content.
    :param resources: The computation resources of the plugin.
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.json'
    log.debug(f'Writing chart {file_path}')

    with open(file_path, 'x') as out_file:
        chart_data = data.model_dump(mode='json')
        json.dump(chart_data,
                  out_file,
                  indent=4)

    result = Artifact(name=title,
                      modality=ArtifactModality.CHART,
                      file_path=file_path,
                      summary=caption,
                      description=description)
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_geojson_artifact(features: GeoSeries,
                            layer_name: str,
                            caption: str,
                            resources: ComputationResources,
                            description: str = None,
                            color: Union[List[Color], Color] = Color('#590d08'),
                            filename: str = uuid.uuid4()) -> Artifact:
    """Create a vector data artifact.

    This will create a GeoJSON file holding all information required to plot a simple map layer.

    :param features: The Geodata. Must have a CRS set.
    :param color: Color of the features. Will be applied to surfaces, lines and points. Must be either a single color
    or the same length as the features.
    :param layer_name: Name of the map layer.
    :param caption: A short description of the layer.
    :param description: A longer description of the layer.
    :param resources: The computation resources of the plugin.
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.geojson'
    log.debug(f'Writing vector dataset {file_path}')

    if not isinstance(color, List):
        color = [color] * features.size
    assert len(color) == features.size, 'The number of colors given does not match the number of features given.'
    color = [color.as_hex() for color in color]

    assert features.crs, 'CRS must be set.'

    gdf = GeoDataFrame({'color': color},
                       geometry=features)

    with open(file_path, 'x') as out_file:
        json_str = gdf.to_json(show_bbox=True,
                               to_wgs84=True,
                               indent=4)
        out_file.write(json_str)

    result = Artifact(name=layer_name,
                      modality=ArtifactModality.MAP_LAYER_GEOJSON,
                      file_path=file_path,
                      summary=caption,
                      description=description)
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_geotiff_artifact(data: ArrayLike,
                            crs: CRS,
                            transformation: Affine,
                            layer_name: str,
                            caption: str,
                            resources: ComputationResources,
                            description: str = None,
                            colormap: Optional[Dict[Number, Tuple[int, int, int]]] = None,
                            nodata: Number = 0,
                            filename: str = uuid.uuid4()) -> Artifact:
    """Create a raster data artifact.

    This will create a GeoTIFF file holding all information required to plot a simple map layer.

    :param data: The array to write to the image. Must be 2 or 3d.
    :param crs: The coordinate reference system.
    :param transformation: An affine transformation. This is best read from an existing image or
    using https://github.com/rasterio/affine
    :param colormap: An optional colormap for easy display.
    :param nodata: The no-data value
    :param layer_name: Name of the map layer.
    :param caption: A short description of the layer.
    :param description: A longer description of the layer.
    :param resources: The computation resources of the plugin.
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.tiff'
    log.debug(f'Writing raster dataset {file_path}')

    if data.ndim == 2:
        height = data.shape[0]
        width = data.shape[1]
        count = 1
    elif data.ndim == 3:
        height = data.shape[1]
        width = data.shape[2]
        count = data.shape[0]
    else:
        raise ValueError('Only 2 and 3 dimensional arrays are supported.')

    profile = {
        'height': height,
        'width': width,
        'count': count,
        'dtype': data.dtype,
        'crs': crs,
        'nodata': nodata,
        'photometric': 'RGB',
        'transform': transformation
    }

    with rasterio.open(file_path, mode='w', **DefaultGTiffProfile(**profile)) as out_map_file:
        out_map_file.write(data)
        if colormap:
            out_map_file.write_colormap(1, colormap)

    result = Artifact(name=layer_name,
                      modality=ArtifactModality.MAP_LAYER_GEOTIFF,
                      file_path=file_path,
                      summary=caption,
                      description=description)
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result
