import json
import logging
import uuid
from enum import Enum
from numbers import Number
from pathlib import Path
from typing import Optional, Union, List, Dict, Any
from uuid import UUID

import numpy as np
import rasterio
from PIL.Image import Image
from affine import Affine
from geopandas import GeoSeries, GeoDataFrame
from numpy.typing import ArrayLike
from pandas import DataFrame
from pydantic import (
    BaseModel,
    Field,
    model_validator,
    conlist,
    field_serializer,
    conint,
    confloat,
    field_validator,
    computed_field,
)
from pydantic_extra_types.color import Color
from rasterio import CRS
from rasterio.profiles import DefaultGTiffProfile

from climatoology.base.computation import ComputationResources

log = logging.getLogger(__name__)

ACCEPTABLE_COLORMAPS = (
    'plasma',
    'binary',
    'RdYlGn',
    'seismic',
    'terrain',
)  # extend from https://matplotlib.org/stable/users/explain/colors/colormaps.html at will


class LegendType(Enum):
    DISCRETE = 'DISCRETE'
    CONTINUOUS = 'CONTINUOUS'


class ContinuousLegendData(BaseModel):
    cmap_name: str = Field(
        title='Color Map Name',
        description='The name of the colormap the colors where picked from. Must be a matplotlib colormap, '
        'see https://matplotlib.org/stable/users/explain/colors/colormaps.html.',
        examples=['seismic'],
    )
    ticks: Dict[str, confloat(ge=0, le=1)] = Field(
        title='Ticks',
        description='Label and location of the legend ticks. The key represents the label the tick should have. It can '
        'be a data value (e.g. 0.5), a data value string (e.g. 0.5Â°C) or a string (e.g. '
        '`low temperature`). The value defines the location of the ticks between 0 (lowest) and 1 '
        '(highest value on the legend scale).',
        examples=[
            {'low': 0, 'high': 1},
        ],
    )

    @field_validator('cmap_name')
    def must_be_valid_cmap_name(cls, v: str) -> str:
        if v.removesuffix('_r') not in ACCEPTABLE_COLORMAPS:
            raise ValueError(f'{v} is not among the accepted colormaps.')
        return v


class Legend(BaseModel):
    legend_data: Union[Dict[str, Color], ContinuousLegendData] = Field(
        title='Legend Data',
        description='The data that is required to plot the legend. For discrete legends, all unique values with their '
        'respective color must be given. For continuous legends, a continuous legend object is required.',
        examples=[
            {'The black void', Color('black').as_hex()},
            ContinuousLegendData(cmap_name='seismic', ticks={'low': 0, 'high': 1}),
        ],
    )

    @computed_field()
    def legend_type(self) -> LegendType:
        if isinstance(self.legend_data, dict):
            return LegendType.DISCRETE
        elif isinstance(self.legend_data, ContinuousLegendData):
            return LegendType.CONTINUOUS
        else:
            raise ValueError(f'Legend data type {type(self.legend_data)} not supported')

    @field_serializer('legend_data')
    def serialize_color(self, co: Union[Dict[str, Color], ContinuousLegendData], _info):
        if isinstance(co, dict):
            return {lab: c.as_hex() for lab, c in co.items()}
        else:
            return co.model_dump()


class ArtifactModality(Enum):
    """Available artifact types."""

    MARKDOWN = 'MARKDOWN'
    TABLE = 'TABLE'
    IMAGE = 'IMAGE'
    CHART = 'CHART'
    MAP_LAYER_GEOJSON = 'MAP_LAYER_GEOJSON'
    MAP_LAYER_GEOTIFF = 'MAP_LAYER_GEOTIFF'
    COMPUTATION_INFO = 'COMPUTATION_INFO'


class AttachmentType(Enum):
    LEGEND = 'LEGEND'


class _Artifact(BaseModel):
    """A result generated by a Plugin.

    It should not be instantiated directly. Convenience creation methods for each artifact type are provided. This
    assures format consistency and reduces necessary plugin code changes.
    """

    name: str = Field(
        description='A short name for the artifact that could be used as an alias.',
        min_length=1,
        examples=['Nice Graphic'],
    )
    modality: ArtifactModality = Field(description='The type of artefact created.', examples=[ArtifactModality.IMAGE])
    primary: bool = Field(
        description='Is this a primary artifact or does it exhibit additional or contextual information?',
        examples=[True],
        default=True,
    )
    file_path: Path = Field(
        description='The full path to the file that stores the artefact.',
        examples=['/tmp/7dbcabe2-0961-44ad-b8a2-03a61f45d059_image.png'],
    )
    summary: str = Field(
        description='A short description of the artifact that could be used in a caption.',
        min_length=1,
        examples=['This image shows A.'],
    )
    description: Optional[str] = Field(
        description='A long description of the generated output that may help users better understand the artifact.',
        min_length=1,
        examples=['This image shows A and was taken from B by C because of D.'],
        default=None,
    )
    correlation_uuid: Optional[UUID] = Field(
        description='Do not set! The correlation UUID for this call. Will be automatically set by the plugin.',
        default=None,
    )
    store_id: Optional[str] = Field(
        description='Do not set! This is the pointer to the file in the artifactory store. '
        'Will be automatically set.',
        examples=['7dbcabe2-0961-44ad-b8a2-03a61f45d059_image.png'],
        default=None,
    )
    attachments: Dict[AttachmentType, Any] = Field(
        description='Additional information or files that are linked to this artifact.',
        examples=[{AttachmentType.LEGEND: Legend(legend_data={'The red object': Color('red')})}],
        default={},
    )


class ChartType(Enum):
    SCATTER = 'SCATTER'
    LINE = 'LINE'
    BAR = 'BAR'
    PIE = 'PIE'


class Chart2dData(BaseModel):
    x: Union[conlist(float, min_length=1), conlist(str, min_length=1)] = Field(
        title='X values',
        description='Data values on the X axis. '
        'Must be the same length as '
        'y values. Only one of both '
        'can be a nominal variable '
        '(string). For Pie-Charts, '
        'all values must be '
        'positive numbers. They '
        'will be interpreted as '
        'share, i.e. divided by '
        'the sum.',
        examples=[['first', 'second', 'third']],
    )
    y: Union[conlist(float, min_length=1), conlist(str, min_length=1)] = Field(
        title='Y values',
        description='Data values on the Y axis. '
        'Must be the same length as '
        'x values. Only one of both '
        'can be a nominal variable '
        '(string).',
        examples=[[3, 2, 1]],
    )
    chart_type: ChartType = Field(
        title='Chart Type', description='The type of chart to be created.', examples=[ChartType.SCATTER]
    )
    color: Union[List[Color], Color] = Field(
        title='Chart Color',
        description='The color for the chart elements. If a list is given, it '
        'must be the same length as the data input. If only a single '
        'color is given, all elements will have the same color. Line-'
        'Charts accept only a single color (one line=one color).',
        examples=[['#590d08', '#590d08', '#590d08']],
        default='#590d08',
        validate_default=True,
    )

    @model_validator(mode='after')
    def check_length(self) -> 'Chart2dData':
        assert len(self.x) == len(self.y), 'X and Y data must be the same length.'

        if self.chart_type == ChartType.LINE:
            assert isinstance(self.color, Color), 'Line charts can only have a single color for the line.'
        else:
            assert isinstance(self.color, Color) or (
                len(self.color) == len(self.x)
            ), 'Data and color lists must be the same length.'

        return self

    @model_validator(mode='after')
    def check_type(self) -> 'Chart2dData':
        assert isinstance(self.x[0], float) or isinstance(
            self.y[0], float
        ), 'Only one dimension can be nominal (a str).'
        return self

    @model_validator(mode='after')
    def check_data(self) -> 'Chart2dData':
        if self.chart_type == ChartType.PIE:
            assert isinstance(self.y[0], float), 'Pie-chart Y-Axis must be numeric.'
            assert all(val >= 0 for val in self.y), 'Pie-chart Y-Data must be all positive.'
        return self

    @field_serializer('color')
    def serialize_color_list(self, co: Union[Color, List[Color]], _info):
        if isinstance(co, Color):
            return co.as_hex()
        else:
            return [c.as_hex() for c in co]


def create_markdown_artifact(
    text: str,
    resources: ComputationResources,
    name: str,
    tl_dr: str,
    primary: bool = True,
    filename: str = uuid.uuid4(),
) -> _Artifact:
    """Create an artifact from text supporting Markdown formatting.

    You may use raw text or add any formatting to style your text using e.g. headings, emphasis or links.

    :param text: Text that can contain Markdown formatting.
    :param name: A potential heading for the text.
    :param tl_dr: A summary of the text.
    :param primary: Is this a primary artifact or does it exhibit additional or contextual information?
    :param resources: The computation resources for this plugin.
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.md'
    log.debug(f'Writing markdown file {file_path}')

    with open(file_path, 'x') as out_file:
        out_file.write(text)

    result = _Artifact(
        name=name,
        modality=ArtifactModality.MARKDOWN,
        file_path=file_path,
        summary=tl_dr,
        primary=primary,
    )
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_table_artifact(
    data: DataFrame,
    title: str,
    caption: str,
    resources: ComputationResources,
    primary: bool = True,
    description: str = None,
    filename: str = uuid.uuid4(),
) -> _Artifact:
    """Create an artifact from a data frame.

    This will create a CSV file. Any index will be written as a normal column.

    :param data: Table to save as csv.
    :param title: Title or name of the table.
    :param caption: Caption of the table that describes the content.
    :param description: A longer description of the table content.
    :param resources: The computation resources for this plugin.
    :param primary: Is this a primary artifact or does it exhibit additional or contextual information?
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.csv'
    log.debug(f'Writing table {file_path}')

    data = data.reset_index()
    data.to_csv(file_path, header=True, index=False, index_label=False, mode='x')

    result = _Artifact(
        name=title,
        modality=ArtifactModality.TABLE,
        file_path=file_path,
        summary=caption,
        description=description,
        primary=primary,
    )
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_image_artifact(
    image: Image,
    title: str,
    caption: str,
    resources: ComputationResources,
    primary: bool = True,
    description: str = None,
    filename: str = uuid.uuid4(),
) -> _Artifact:
    """Create an artifact from a pillow image.

    This will create a PNG file.

    :param image: Image to save as PNG.
    :param title: Title or name of the image.
    :param caption: Caption of the image that describes the content.
    :param description: A longer description of the image content.
    :param resources: The computation resources for this plugin.
    :param primary: Is this a primary artifact or does it exhibit additional or contextual information?
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.png'
    log.debug(f'Writing image {file_path}')

    assert image.mode in ('1', 'L', 'LA', 'I', 'P', 'RGB', 'RGBA'), f'Image mode {image.mode} not supported.'

    image.save(file_path, format='PNG', optimize=True)

    result = _Artifact(
        name=title,
        modality=ArtifactModality.IMAGE,
        file_path=file_path,
        summary=caption,
        description=description,
        primary=primary,
    )
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_chart_artifact(
    data: Chart2dData,
    title: str,
    caption: str,
    resources: ComputationResources,
    primary: bool = True,
    description: str = None,
    filename: str = uuid.uuid4(),
) -> _Artifact:
    """Create a chart artifact.

    This will create a JSON file holding all information required to plot a simple 2d chart.

    :param data: Chart data
    :param title: Title for the resulting plot.
    :param caption: Caption for the resulting plot that describes the content.
    :param description: A longer description of the chart content.
    :param resources: The computation resources of the plugin.
    :param primary: Is this a primary artifact or does it exhibit additional or contextual information?
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.json'
    log.debug(f'Writing chart {file_path}')

    with open(file_path, 'x') as out_file:
        chart_data = data.model_dump(mode='json')
        json.dump(chart_data, out_file, indent=4)

    result = _Artifact(
        name=title,
        modality=ArtifactModality.CHART,
        file_path=file_path,
        summary=caption,
        description=description,
        primary=primary,
    )
    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


def create_geojson_artifact(
    features: GeoSeries,
    layer_name: str,
    caption: str,
    color: List[Color],
    label: List[str],
    resources: ComputationResources,
    primary: bool = True,
    legend_data: Union[ContinuousLegendData, Dict[str, Color]] = None,
    description: str = None,
    filename: str = uuid.uuid4(),
) -> _Artifact:
    """Create a vector data artifact.

    This will create a GeoJSON file holding all information required to plot a simple map layer.

    :param features: The Geodata. Must have a CRS set.
    :param color: Color of the features. Will be applied to surfaces, lines and points. Must be the same length as the
    features.
    :param label: Label of the features. Must be the same length as the features.
    :param layer_name: Name of the map layer.
    :param caption: A short description of the layer.
    :param description: A longer description of the layer.
    :param legend_data: Can be used to display a custom legend. For a continuous legend, use the ContinousLegendData
    type. For a legend with distinct colors provide a dictionary mapping labels (str) to colors. If not provided, a
    distinct legend will be created from the unique combinations of labels and colors.
    :param resources: The computation resources of the plugin.
    :param primary: Is this a primary artifact or does it exhibit additional or contextual information?
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.geojson'
    log.debug(f'Writing vector dataset {file_path}.')

    assert len(color) == features.size, 'The number of colors does not match the number of features.'
    color = [color.as_hex() for color in color]

    assert len(label) == features.size, 'The number of labels does not match the number of features.'

    assert features.crs, 'CRS must be set.'

    gdf = GeoDataFrame({'color': color, 'label': label}, geometry=features.reset_index(drop=True))

    with open(file_path, 'x') as out_file:
        json_str = gdf.to_json(show_bbox=True, to_wgs84=True, indent=4)
        out_file.write(json_str)

    if not legend_data:
        legend_df = gdf.groupby(['color', 'label']).size().index.to_frame(index=False)
        legend_df = legend_df.set_index('label')
        legend_data = legend_df.to_dict()['color']

    result = _Artifact(
        name=layer_name,
        modality=ArtifactModality.MAP_LAYER_GEOJSON,
        file_path=file_path,
        summary=caption,
        description=description,
        primary=primary,
        attachments={AttachmentType.LEGEND: Legend(legend_data=legend_data)},
    )

    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result


class RasterInfo(BaseModel, arbitrary_types_allowed=True):
    data: ArrayLike = Field(
        title='Input data',
        description='The array of raster values to write to the image. Must be 2d or 3d.',
        examples=[[[1, 1], [1, 1]]],
    )
    crs: CRS = Field(
        title='CRS',
        description='The coordinate reference system.',
        examples=[CRS({'init': 'epsg:4326'}).to_string()],
    )
    transformation: Affine = Field(
        title='Transformation',
        description='An affine transformation. This is best read from an existing image or '
        'using https://github.com/rasterio/affine',
        examples=[Affine.identity()],
    )
    colormap: Optional[Dict[Number, conlist(item_type=conint(ge=0, le=255), min_length=3, max_length=4)]] = Field(
        title='Colormap',
        description='An optional colormap for easy '
        'display. It will be applied to the '
        'first layer of the image and '
        'resolves all possible array data '
        'values (key) to the respective '
        'RGB-color (value).',
        examples=[{1: Color('red').as_rgb_tuple()}],
        default=None,
    )
    nodata: Number = Field(
        title='No-Data Value',
        description='The array values that signifies no-data in the raster.',
        examples=[0],
        default=0,
    )


def create_geotiff_artifact(
    raster_info: RasterInfo,
    layer_name: str,
    caption: str,
    resources: ComputationResources,
    primary: bool = True,
    legend_data: Union[ContinuousLegendData, Dict[str, Color]] = None,
    description: str = None,
    filename: str = uuid.uuid4(),
) -> _Artifact:
    """Create a raster data artifact.

    This will create a GeoTIFF file holding all information required to plot a simple map layer.

    :param raster_info: The RasterInfo object.
    :param layer_name: Name of the map layer.
    :param caption: A short description of the layer.
    :param description: A longer description of the layer.
    :param legend_data: Can be used to display a custom legend. For a continuous legend, use the ContinousLegendData type.
    For a legend with distinct colors provide a dictionary mapping labels (str) to colors. If not provided, a distinct
    legend will be created from the colormap, if it exists.
    :param resources: The computation resources of the plugin.
    :param primary: Is this a primary artifact or does it exhibit additional or contextual information?
    :param filename: A filename for the created file (without extension!).
    :return: The artifact that contains a path-pointer to the created file.
    """
    file_path = resources.computation_dir / f'{filename}.tiff'
    log.debug(f'Writing raster dataset {file_path}.')

    data_array = np.array(raster_info.data)

    assert np.issubdtype(data_array.dtype, np.number), 'Array must be numeric'
    assert min(data_array.shape) > 0, 'Input array cannot have zero length dimensions.'

    if data_array.ndim == 2:
        count = 1
        height = data_array.shape[0]
        width = data_array.shape[1]

        indexes = count
    elif data_array.ndim == 3:
        count = data_array.shape[0]
        height = data_array.shape[1]
        width = data_array.shape[2]

        indexes = list(range(1, count + 1))
    else:
        raise ValueError('Only 2 and 3 dimensional arrays are supported.')

    profile = {
        'height': height,
        'width': width,
        'count': count,
        'dtype': data_array.dtype,
        'crs': raster_info.crs,
        'nodata': raster_info.nodata,
        'photometric': 'RGB',
        'transform': raster_info.transformation,
    }

    with rasterio.open(file_path, mode='w', **DefaultGTiffProfile(**profile)) as out_map_file:
        out_map_file.write(data_array, indexes=indexes)
        if raster_info.colormap:
            out_map_file.write_colormap(1, raster_info.colormap)

    legend = None
    if legend_data:
        legend = Legend(legend_data=legend_data)
    elif raster_info.colormap:
        legend_data = {
            str(k): Color(v if len(v) == 3 else (v[0], v[1], v[2], v[3] / 255)) for k, v in raster_info.colormap.items()
        }
        legend = Legend(legend_data=legend_data)

    result = _Artifact(
        name=layer_name,
        modality=ArtifactModality.MAP_LAYER_GEOTIFF,
        file_path=file_path,
        summary=caption,
        description=description,
        primary=primary,
        attachments={AttachmentType.LEGEND: legend} if legend else {},
    )

    log.debug(f'Returning Artifact: {result.model_dump()}.')

    return result
