import base64
import shutil
import tempfile
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from io import BytesIO
from pathlib import Path
from typing import Optional, List, Generic, TypeVar, Dict, Type, Any, get_origin, get_args, final
from uuid import UUID

import bibtexparser
from PIL import Image
from pydantic import BaseModel, field_validator, Extra
from semver import Version

import climatoology


class Concern(Enum):
    """Keywords that group plugins by topic."""
    CLIMATE_ACTION__GHG_EMISSION = 'ghg_emission'
    CLIMATE_ACTION__MITIGATION = 'mitigation'
    CLIMATE_ACTION__ADAPTION = 'adaption'

    SUSTAINABILITY__WASTE = 'waste'


class Info(BaseModel):
    """A dataclass to provide the basic information about an operator/ a plugin.

    :param name: A short and concise name that can be used in the UI
    :param icon: An image or icon that can be used in the UI. Make sure the file is committed to the repository,
    and you have all rights to use it.
    :param version: The plugin version. You can start at 0.0.1 for your first try and then got 1.0.0 for your first
    release, increasing as you update the code.
    :param concerns: A set of keywords that can be used to group multiple plugins.
    :param purpose: What will this operator accomplish?
    :param methodology: How does the operator achieve its goal?
    :param sources: A list of sources that were used in the process or are related. Self-citations are welcome
    and even preferred!
    :param operator_schema: Do not set! It will be overridden by the plugin with the schematic description of the parameters
    necessary to initiate a computation.
    :param library_version: Do not set!
    """
    name: str
    icon: str
    version: str
    concerns: List[Concern]
    purpose: str
    methodology: str
    sources: Optional[List[dict]] = None
    operator_schema: Optional[dict] = None
    library_version: str = climatoology.__version__

    @field_validator('version', mode='before')
    @classmethod
    def _convert_version(cls, version: Any) -> str:
        if isinstance(version, Version):
            return str(version)
        return version

    @classmethod
    def _verify_icon(cls, icon: Path) -> None:
        image = Image.open(icon)
        image.verify()

    @field_validator('icon', mode='before')
    @classmethod
    def _convert_icon(cls, icon: Any) -> str:
        if isinstance(icon, Path):
            Info._verify_icon(icon)
            image = Image.open(icon)
            image.thumbnail((500, 500))
            buffered = BytesIO()
            image.save(buffered, format='JPEG')
            buffered.seek(0)
            data_url = base64.b64encode(buffered.getvalue()).decode('UTF-8')
            return f'data:image/jpeg;base64,{data_url}'
        return icon

    @field_validator('sources', mode='before')
    @classmethod
    def _convert_bib(cls, sources: Any) -> dict:
        if isinstance(sources, Path):
            with open(sources, mode='r') as file:
                return bibtexparser.load(file).get_entry_list()
        return sources

    @field_validator('concerns', mode='before')
    @classmethod
    def _convert_concerns(cls, concerns: Any) -> List[Concern]:
        if isinstance(concerns, List):
            return [Concern(x) for x in concerns]
        return concerns


class Config:
    extra = Extra.forbid


class ArtifactModality(Enum):
    """Available artifact types."""
    TEXT = 'TEXT'
    """A string. This can either be a static output provided by your operator, or a parametrised text that changes
        based on the operator results generated. It is meant for end-users. Use .txt-files for storage."""
    TABLE = 'TABLE'
    """A table. Use .csv-files for storage, first line is expected to contain the column names."""
    MAP_LAYER = 'MAP_LAYER'
    """Geodata. Either a .gpkg for vector data or a .tiff (geotiff) for raster data."""
    IMAGE = 'IMAGE'
    """A non-georeferenced image."""
    URL = 'URL'
    """A string that points to a public website in the form of https://dns.end/path . Use .txt files for storage."""


class Artifact(BaseModel):
    """A result generated by an Operator."""
    name: str
    """A short name for the artifact that could be used as an alias."""
    modality: ArtifactModality
    """The type of artefact created."""
    file_path: Path
    """The full path to the file that stores the artefact. The file-type must be in line with the type of artefact
    (see ArtifactModality documentation)."""
    summary: str
    """A short description of the artifact that could be used in a caption."""
    description: str
    """A long description of the generated output that may help users better understand the artifact."""
    correlation_uuid: Optional[UUID] = None
    """Do not set! The correlation UUID for this call. Will be automatically set by the plugin."""
    params: Optional[dict] = None
    """Do not set! The parameters for this call. Will be automatically set by the plugin."""
    store_id: Optional[str] = None
    """Do not set! This is the pointer to the file in the artifactory store. Will be automatically set."""


T_co = TypeVar('T_co', bound=BaseModel, covariant=True)


@dataclass
class ComputationResources:
    correlation_uuid: UUID
    computation_dir: Path


class ComputationScope:
    def __init__(self, correlation_uuid: UUID):
        self.resources = ComputationResources(computation_dir=Path(tempfile.mkdtemp(prefix=str(correlation_uuid))),
                                              correlation_uuid=correlation_uuid)

    def __enter__(self):
        return self.resources

    def __exit__(self, *args):
        shutil.rmtree(self.resources.computation_dir)


class Operator(ABC, Generic[T_co]):
    """Climate Action indicator logic.

    The operator provides the core functionality for the plugin.
     Each application that serves a plugin is required to implement its own operator.
    """

    _model: Optional[Type[T_co]] = None

    @classmethod
    def __init_subclass__(cls, **kwargs: Any) -> None:
        """
        Verify whether subclass follows the model contract defined by the
        Operator superclass

        :param kwargs:
        :return:
        """

        super().__init_subclass__(**kwargs)
        for base in cls.__orig_bases__:  # type: ignore[attr-defined]
            origin = get_origin(base)
            if origin is None or not issubclass(origin, Operator):
                continue
            type_arg = get_args(base)[0]
            if not isinstance(type_arg, TypeVar):
                cls._model = type_arg
                return
        assert cls._model, 'Could not initialise the compute input type model. Did you properly subtype your operator?'

    @final
    def info_enriched(self) -> Info:
        """Describe the operators' purpose, functionality, methodology and sources.

        :return: operator info
        """
        info = self.info()
        info.operator_schema = self._model.model_json_schema()
        return info

    @abstractmethod
    def info(self) -> Info:
        """Describe the operators' purpose, functionality, methodology and sources.

        :return: operator info
        """
        pass

    @final
    def compute_unsafe(self, resources: ComputationResources, params: Dict) -> List[Artifact]:
        """
        Translated the incoming parameters to a declared pydantic model,
        validates input and runs the compute procedure.

        :param resources: computation ephemeral resources
        :param params: computation configuration parameters
        :return:
        """

        validate_params = self._model(**params)
        return self.compute(resources, validate_params)

    @abstractmethod
    def compute(self, resources: ComputationResources, params: T_co) -> List[Artifact]:
        """Generate an operator-specific report.

        A report is made up of a set of artifacts that can be displayed by a client.

        :param resources: computation ephemeral resources
        :param params: computation parameters in the form of the declared pydantic module
        :return: list of artifacts (files) produced by the operator
        """
        pass
